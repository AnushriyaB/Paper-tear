<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Paper tearing</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

  :root {
    --bg: #ECE6DF;
    --accent: #2D2D25;
    --border: #8B4A2B;
    --cardboard-fill:
      linear-gradient(180deg, rgba(180,141,84,0.2), rgba(139,74,43,0.2)),
      repeating-linear-gradient(
        0deg,
        rgba(106,90,70,0.06) 0px,
        rgba(106,90,70,0.06) 2px,
        rgba(148,85,52,0.05) 2px,
        rgba(148,85,52,0.05) 4px
      ),
      #8B4A2B;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    background-image:
      radial-gradient(circle at 18% 12%, rgba(180,141,84,0.09), transparent 38%),
      radial-gradient(circle at 82% 78%, rgba(124,122,88,0.09), transparent 36%),
      url("data:image/svg+xml,%3Csvg width='6' height='6' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='0' y='0' width='1' height='1' fill='%232D2D25' opacity='0.012'/%3E%3Crect x='3' y='3' width='1' height='1' fill='%238B4A2B' opacity='0.01'/%3E%3C/svg%3E");
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    overflow: hidden;
    font-family: 'DotGothic16', monospace;
    image-rendering: pixelated;
  }

  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 460px;
    margin-bottom: 14px;
    z-index: 90;
    position: relative;
    padding: 8px 10px;
    border: 1px solid rgba(139,74,43,0.22);
    background: rgba(236,230,220,0.78);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0 4px 14px rgba(45,45,37,0.08);
  }

  .counter-text {
    font-family: 'Nanum Myeongjo', serif;
    font-size: 13px;
    color: rgba(45,45,37,0.88);
    letter-spacing: 1px;
    opacity: 0.7;
  }
  .counter-text span {
    font-family: 'DotGothic16', monospace;
    font-size: 14px;
    opacity: 1;
    color: rgba(45,45,37,0.98);
  }

  .reset-btn {
    background: rgba(226,214,200,0.62);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    color: var(--accent);
    border: 1px solid rgba(139,74,43,0.35);
    padding: 6px 18px;
    font-family: 'Nanum Myeongjo', serif;
    font-size: 12px;
    cursor: pointer;
    letter-spacing: 2px;
    border-radius: 2px;
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
  }
  .top-actions {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .tear-all-btn {
    background: rgba(180,141,84,0.22);
    color: var(--accent);
    border: 1px dashed rgba(124,122,88,0.6);
    padding: 6px 12px;
    font-family: 'DotGothic16', monospace;
    font-size: 10px;
    cursor: pointer;
    letter-spacing: 1px;
    border-radius: 2px;
    transition: all 0.2s ease;
  }
  .tear-all-btn:hover {
    background: rgba(180,141,84,0.32);
    border-color: rgba(124,122,88,0.8);
  }
  .reset-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, transparent 60%);
    pointer-events: none;
  }
  .reset-btn:hover {
    background: rgba(226,214,200,0.82);
    border-color: rgba(139,74,43,0.5);
    box-shadow: 0 1px 10px rgba(45,45,37,0.12);
  }
  .reset-btn:active {
    background: rgba(240,235,225,0.6);
    transform: scale(0.97);
  }

  .frame-wrapper {
    position: relative;
    width: 460px;
    height: 580px;
    margin-top: 28px;
    z-index: 30;
  }

  .archive-wall {
    position: fixed;
    top: 8px;
    left: 10px;
    right: 10px;
    height: 160px;
    padding: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-content: flex-start;
    z-index: 60;
    pointer-events: none;
    overflow: visible;
  }
  .archive-item {
    width: 92px;
    height: 116px;
    overflow: hidden;
    opacity: 0.78;
    filter: saturate(0.8) brightness(0.92);
    box-shadow: 0 5px 12px rgba(45,45,37,0.2);
    border: 1px solid rgba(124,122,88,0.45);
    background: rgba(207,196,180,0.7);
  }
  .archive-item .frame-wrapper {
    margin-top: 0 !important;
    transform: scale(0.22);
    transform-origin: top left;
  }
  .archive-item .top-bar,
  .archive-item .hint,
  .archive-item #fallCanvas {
    display: none !important;
  }
  .archive-flyer {
    position: fixed;
    pointer-events: none;
    z-index: 350;
    transform-origin: top left;
    transition: transform 0.52s cubic-bezier(0.2, 0.85, 0.22, 1), opacity 0.52s ease;
  }
  .archive-flyer .frame-wrapper {
    margin-top: 0 !important;
  }

  /* Spiral binding */
  .spiral-binding {
    position: absolute;
    top: -18px;
    left: 10px;
    right: 10px;
    height: 36px;
    z-index: 999;
    pointer-events: none;
  }
  .spiral-svg {
    width: 100%;
    height: 100%;
  }

  .frame {
    position: absolute;
    inset: 0;
    transition: none;
  }
  .backboard {
    position: absolute;
    inset: 0;
    background: var(--cardboard-fill);
    z-index: 0;
    pointer-events: none;
  }

  /* Exit animation */
  .frame.exit-left {
    animation: flyLeft 0.5s cubic-bezier(0.55, 0, 1, 0.45) forwards;
  }
  /* Enter animation */
  .frame.enter-right {
    animation: enterRight 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  .spiral-binding.exit-left {
    animation: flyLeft 0.5s cubic-bezier(0.55, 0, 1, 0.45) forwards;
  }
  .spiral-binding.enter-right {
    animation: enterRight 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes flyLeft {
    0% { transform: translate(0,0) rotate(0deg); opacity: 1; }
    30% { transform: translate(-40px, -20px) rotate(-3deg); opacity: 1; }
    100% { transform: translate(-1200px, 80px) rotate(-18deg); opacity: 0; }
  }
  @keyframes enterRight {
    0% { transform: translate(1200px, 60px) rotate(12deg); opacity: 0; }
    40% { opacity: 1; }
    70% { transform: translate(-8px, -4px) rotate(-0.5deg); }
    85% { transform: translate(3px, 2px) rotate(0.2deg); }
    100% { transform: translate(0,0) rotate(0deg); opacity: 1; }
  }

  .paper-layer {
    position: absolute;
    display: flex;
    flex-direction: column;
    overflow: visible;
    pointer-events: none;
    transition: left 0.36s cubic-bezier(0.16, 1, 0.3, 1), top 0.36s cubic-bezier(0.16, 1, 0.3, 1), width 0.36s ease, height 0.36s ease;
  }

  .paper-inner {
    display: flex;
    flex-direction: column;
    border: 3px solid var(--border);
    overflow: hidden;
    height: 100%;
    box-shadow: inset 0 0 0 1px rgba(139,115,85,0.15);
    pointer-events: none;
  }

  .paper-top {
    height: 55%;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    flex-shrink: 0;
    cursor: default;
    pointer-events: auto;
  }

  .paper-top h1 {
    font-family: 'Nanum Myeongjo', serif;
    font-size: 30px;
    font-weight: 700;
    color: rgba(92,64,51,0.16);
    letter-spacing: 4px;
    pointer-events: none;
    user-select: none;
  }

  .tear-line {
    height: 0;
    border-top: 2px dashed rgba(92,64,51,0.25);
    flex-shrink: 0;
  }

  .strips-zone {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(var(--strip-count, 7), minmax(0, 1fr));
    min-height: 0;
    /* Let torn gaps pass through to lower sheets */
    pointer-events: none;
  }

  .strip-slot {
    position: relative;
    min-height: 0;
    overflow: visible;
  }

  .strip {
    width: 100%;
    height: 100%;
    position: relative;
    cursor: grab;
    user-select: none;
    -webkit-user-select: none;
    transform-origin: top center;
    border-right: 1px solid rgba(45,45,37,0.09);
    will-change: transform, opacity, box-shadow, filter;
    /* Re-enable events on actual strip pieces only */
    pointer-events: auto;
  }
  .strip-slot:last-child .strip { border-right: none; }
  .strip.torn {
    visibility: hidden;
    pointer-events: none;
    box-shadow: none !important;
    filter: none !important;
    transform: none !important;
    opacity: 0 !important;
  }
  .strip::after {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;
    opacity: 0;
    background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.08) 24%, rgba(45,45,37,0.16) 100%);
    transition: opacity 0.12s ease;
  }
  .strip.dragging::after { opacity: 1; }

  .strip-num {
    position: absolute;
    bottom: 8px;
    left: 8px;
    font-family: 'DotGothic16', monospace;
    font-size: 11px;
    color: rgba(45,45,37,0.6);
    pointer-events: none;
    user-select: none;
    line-height: 1;
  }
  .strip:hover:not(.torn):not(.dragging) {
    filter: brightness(0.975);
    /* Keep tear edge anchored; lift from lower part */
    transform: perspective(640px) rotateX(-9deg) translateY(-1px);
    box-shadow: 0 8px 12px rgba(45,45,37,0.12);
    transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
  }
  .strip { transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.15s ease; }

  .strip.tearing {
    will-change: clip-path, transform, opacity, box-shadow, filter;
  }
  .strip.held {
    position: fixed !important;
    z-index: 200;
    pointer-events: none;
    filter: drop-shadow(0 8px 16px rgba(45,45,37,0.22));
    transition: none;
    will-change: transform;
  }

  .paper-top.tearable:hover:not(.torn):not(.dragging) {
    transform: translateY(-4px);
    box-shadow: 0 6px 12px rgba(45,45,37,0.11);
    transition: transform 0.15s ease, box-shadow 0.15s ease;
  }
  .paper-top.tearable { transition: transform 0.2s ease, box-shadow 0.2s ease; }
  .strip.dragging { cursor: grabbing; z-index: 100; }

  .paper-top.tearable { cursor: grab; }
  .paper-top.dragging { cursor: grabbing; }
  .paper-top.torn { display: none; }

  .hint {
    margin-top: 14px;
    font-size: 10px;
    color: #7C7A58;
    letter-spacing: 2px;
    opacity: 0.5;
    z-index: 90;
  }

  .completion-board {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 28px;
    border: 4px solid #6A5A46;
    background: var(--cardboard-fill);
    box-shadow:
      inset 0 0 0 2px rgba(70,54,38,0.22),
      inset 0 14px 24px rgba(70,54,38,0.1),
      0 10px 18px rgba(70,54,38,0.14);
    z-index: 500;
  }
  .completion-board::before {
    content: '';
    position: absolute;
    inset: 10px;
    border: 2px solid rgba(92,64,51,0.25);
    pointer-events: none;
  }
  .completion-board .msg {
    font-family: 'Nanum Myeongjo', serif;
    font-size: 30px;
    line-height: 1.35;
    letter-spacing: 1px;
    color: rgba(71,50,33,0.9);
    text-shadow: 0 1px 0 rgba(255,255,255,0.25);
  }
  .archive-item .completion-board .msg {
    font-size: 22px;
  }

  #fallCanvas {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 1000;
  }
  .frame-wrapper.spawn-enter {
    transform: translateX(100vw) rotate(7deg);
    opacity: 0.94;
  }
  .frame-wrapper.spawn-enter.spawn-enter-active {
    transition: transform 0.52s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.34s ease;
    transform: translateX(0) rotate(0);
    opacity: 1;
  }
</style>
</head>
<body>

<div class="archive-wall" id="archiveWall"></div>

<div class="top-bar">
  <div class="counter-text">Paper torn <span id="cNum">0</span></div>
  <div class="top-actions">
    <button class="tear-all-btn" id="tearAllBtn">TEAR ALL</button>
    <button class="reset-btn" id="resetBtn">다시 놓기 [reset]</button>
  </div>
</div>

<div class="frame-wrapper" id="frameWrapper">
  <div class="spiral-binding" id="spiralBinding"></div>
  <div class="frame" id="frame"></div>
</div>

<div class="hint">↓ pull strips down ↓</div>
<canvas id="fallCanvas"></canvas>

<script src="./src/tearProfiles.js"></script>
<script>
// ═══════════════════════════════════════
// AUDIO
// ═══════════════════════════════════════
const AC = window.AudioContext || window.webkitAudioContext;
let actx;
function initAudio() { if (!actx) actx = new AC(); }

const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

let noiseBuffer = null;
function getNoiseBuffer() {
  if (noiseBuffer) return noiseBuffer;
  initAudio();
  const len = actx.sampleRate * 2;
  noiseBuffer = actx.createBuffer(2, len, actx.sampleRate);
  for (let c = 0; c < 2; c++) {
    const d = noiseBuffer.getChannelData(c);
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
    for (let i = 0; i < len; i++) {
      const w = Math.random() * 2 - 1;
      b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759;
      b2=0.96900*b2+w*0.1538520; b3=0.86650*b3+w*0.3104856;
      b4=0.55000*b4+w*0.5329522; b5=-0.7616*b5-w*0.0168980;
      d[i]=(b0+b1+b2+b3+b4+b5+b6+w*0.5362)*0.11;
      b6=w*0.115926;
    }
  }
  return noiseBuffer;
}

function playTear({ intensity = 0.6, speed = 0.4, direction = 0 } = {}) {
  initAudio();
  const ctx = actx, now = ctx.currentTime, nb = getNoiseBuffer();
  const i = clamp(intensity, 0, 1);
  const s = clamp(speed, 0, 1);
  const dir = clamp(direction, -1, 1);

  // Main body — warm, soft paper tear
  const src = ctx.createBufferSource();
  src.buffer = nb;
  src.playbackRate.value = 0.55 + s * 0.45 + Math.random() * 0.12;
  const env = ctx.createGain();
  env.gain.setValueAtTime(0, now);
  const peak = 0.08 + i * 0.09;
  const sustain = 0.03 + i * 0.05;
  const decay = 0.35 - s * 0.06;
  env.gain.linearRampToValueAtTime(peak, now + 0.018);
  env.gain.setValueAtTime(peak, now + 0.05);
  env.gain.exponentialRampToValueAtTime(sustain, now + 0.15);
  env.gain.exponentialRampToValueAtTime(0.001, now + decay);
  const f1 = ctx.createBiquadFilter();
  f1.type='bandpass';
  f1.frequency.value = 420 + s * 550 + Math.random() * 140;
  f1.Q.value = 0.7 + i * 0.5;
  const f2 = ctx.createBiquadFilter();
  f2.type='highshelf';
  f2.frequency.value = 2200 + s * 600;
  f2.gain.value = -10 + i * 2;

  // Subtle crackle — soft fiber noise
  const crLen = ctx.sampleRate*0.25;
  const crBuf = ctx.createBuffer(1, crLen, ctx.sampleRate);
  const crD = crBuf.getChannelData(0);
  const crackleChance = 0.975 - i * 0.04 - s * 0.015;
  for (let j = 0; j < crLen; j++) {
    const t = j / crLen;
    if (Math.random() > crackleChance) crD[j] = (Math.random() - 0.5) * Math.pow(1 - t, 1.5) * (0.5 + i * 0.4);
  }
  const crSrc = ctx.createBufferSource(); crSrc.buffer = crBuf;
  const crG = ctx.createGain(); crG.gain.value = 0.02 + i * 0.05;
  const crF = ctx.createBiquadFilter();
  crF.type='bandpass';
  crF.frequency.value = 1400 + s * 700;
  crF.Q.value = 0.35 + i * 0.3;

  // Gentle snap transient — soft thud instead of sharp click
  const snapLen = ctx.sampleRate*0.05;
  const snapBuf = ctx.createBuffer(1, snapLen, ctx.sampleRate);
  const snapD = snapBuf.getChannelData(0);
  for (let j=0;j<snapLen;j++) {
    const t=j/snapLen;
    snapD[j]=(Math.random()*2-1)*Math.pow(1-t,5)*0.3;
  }
  const snapSrc = ctx.createBufferSource(); snapSrc.buffer=snapBuf;
  const snapG = ctx.createGain();
  const snapF = ctx.createBiquadFilter(); snapF.type='bandpass'; snapF.frequency.value=600;
  snapG.gain.value = 0.03 + s * 0.04;
  snapF.frequency.value = 400 + s * 400;
  snapF.Q.value = 0.6;

  const panner = typeof ctx.createStereoPanner === 'function' ? ctx.createStereoPanner() : null;
  if (panner) {
    panner.pan.value = dir * 0.35;
    src.connect(f1).connect(f2).connect(env).connect(panner).connect(ctx.destination);
    crSrc.connect(crF).connect(crG).connect(panner);
    snapSrc.connect(snapF).connect(snapG).connect(panner);
  } else {
    src.connect(f1).connect(f2).connect(env).connect(ctx.destination);
    crSrc.connect(crF).connect(crG).connect(ctx.destination);
    snapSrc.connect(snapF).connect(snapG).connect(ctx.destination);
  }
  src.start(now, Math.random()*1.5, 0.45); crSrc.start(now); snapSrc.start(now);
  src.stop(now+0.45); crSrc.stop(now+0.3); snapSrc.stop(now+0.06);
}

function playWhoosh() {
  initAudio();
  const ctx = actx, now = ctx.currentTime;
  const nb = getNoiseBuffer();
  const src = ctx.createBufferSource(); src.buffer = nb; src.playbackRate.value = 0.3;
  const env = ctx.createGain();
  env.gain.setValueAtTime(0, now);
  env.gain.linearRampToValueAtTime(0.08, now+0.1);
  env.gain.exponentialRampToValueAtTime(0.001, now+0.5);
  const lp = ctx.createBiquadFilter(); lp.type='lowpass';
  lp.frequency.setValueAtTime(600, now);
  lp.frequency.exponentialRampToValueAtTime(200, now+0.5);
  src.connect(lp).connect(env).connect(ctx.destination);
  src.start(now, 0, 0.55); src.stop(now+0.55);
}

function playLand() {
  initAudio();
  const ctx = actx, now = ctx.currentTime;
  const nb = getNoiseBuffer();
  const src = ctx.createBufferSource(); src.buffer = nb; src.playbackRate.value = 1.5;
  const env = ctx.createGain();
  env.gain.setValueAtTime(0.08, now);
  env.gain.exponentialRampToValueAtTime(0.001, now+0.15);
  const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=400; bp.Q.value=0.8;
  src.connect(bp).connect(env).connect(ctx.destination);
  src.start(now, 0, 0.2); src.stop(now+0.2);
}

let crinkleNodes = null;
function startCrinkle() {
  initAudio();
  if (crinkleNodes) return;
  const ctx = actx, nb = getNoiseBuffer();
  const src = ctx.createBufferSource(); src.buffer=nb; src.loop=true; src.playbackRate.value=0.4;
  const env = ctx.createGain(); env.gain.value=0;
  env.gain.linearRampToValueAtTime(0.012, ctx.currentTime+0.08);
  const filt = ctx.createBiquadFilter(); filt.type='bandpass'; filt.frequency.value=1200; filt.Q.value=2;
  const lfo = ctx.createOscillator(); lfo.frequency.value=8+Math.random()*6;
  const lfoG = ctx.createGain(); lfoG.gain.value=400;
  lfo.connect(lfoG).connect(filt.frequency); lfo.start();
  src.connect(filt).connect(env).connect(ctx.destination);
  src.start();
  crinkleNodes = { src, env, filt, lfo, ctx };
}
function updateCrinkle(progress, velocity) {
  if (!crinkleNodes) return;
  const { env, filt, src, ctx } = crinkleNodes;
  const p = clamp(progress, 0, 1);
  const v = clamp(velocity / 1.3, 0, 1);
  const now = ctx.currentTime;
  env.gain.cancelScheduledValues(now);
  env.gain.linearRampToValueAtTime(0.008 + p * 0.032 + v * 0.014, now + 0.04);
  filt.frequency.cancelScheduledValues(now);
  filt.frequency.linearRampToValueAtTime(800 + p * 1300 + v * 650, now + 0.05);
  src.playbackRate.cancelScheduledValues(now);
  src.playbackRate.linearRampToValueAtTime(0.28 + p * 0.36 + v * 0.2, now + 0.05);
}
function stopCrinkle() {
  if (!crinkleNodes) return;
  const {src,env,lfo,ctx} = crinkleNodes;
  env.gain.linearRampToValueAtTime(0, ctx.currentTime+0.08);
  setTimeout(()=>{ try{src.stop();lfo.stop();}catch(e){} },100);
  crinkleNodes = null;
}

// ═══════════════════════════════════════
// FALLING PIECES
// ═══════════════════════════════════════
const fallCanvas = document.getElementById('fallCanvas');
const fctx = fallCanvas.getContext('2d');
let fallingPieces = [];

function resizeFC() { fallCanvas.width=window.innerWidth; fallCanvas.height=window.innerHeight; }
resizeFC(); window.addEventListener('resize', resizeFC);

class FallingPiece {
  constructor(x,y,w,h,color,rot,dirX) {
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.color=color; this.rot=rot;
    this.vx=dirX*(2+Math.random()*3); this.vy=-2+Math.random()*2;
    this.vr=(Math.random()-0.5)*5; this.alive=true;
    this.jaggedEdge=[];
    for (let px=0;px<=w;px+=3) this.jaggedEdge.push(Math.random()*8);
  }
  update() {
    this.vy+=0.28; this.vx*=0.992;
    this.vx+=Math.sin(this.y*0.015)*0.12;
    this.x+=this.vx; this.y+=this.vy;
    this.rot+=this.vr; this.vr*=0.997;
    if (this.y > window.innerHeight+50) this.alive=false;
  }
  draw(ctx) {
    ctx.save();
    ctx.translate(this.x+this.w/2, this.y+this.h/2);
    ctx.rotate(this.rot*Math.PI/180);
    ctx.fillStyle=this.color;
    ctx.beginPath();
    ctx.moveTo(-this.w/2, -this.h/2+this.jaggedEdge[0]);
    for (let i=1;i<this.jaggedEdge.length;i++)
      ctx.lineTo(-this.w/2+i*3, -this.h/2+this.jaggedEdge[i]);
    ctx.lineTo(this.w/2, this.h/2);
    ctx.lineTo(-this.w/2, this.h/2);
    ctx.closePath(); ctx.fill();
    // Fiber wisps
    ctx.globalAlpha=0.15; ctx.fillStyle='#5C4033';
    for (let i=0;i<this.jaggedEdge.length;i++) {
      if (Math.random()>0.6)
        ctx.fillRect(-this.w/2+i*3, -this.h/2+this.jaggedEdge[i], 1, 2+Math.random()*3);
    }
    ctx.restore();
  }
}

function animLoop() {
  fctx.clearRect(0,0,fallCanvas.width,fallCanvas.height);
  fallingPieces=fallingPieces.filter(p=>p.alive);
  for (const p of fallingPieces) { p.update(); p.draw(fctx); }
  requestAnimationFrame(animLoop);
}
animLoop();

function spawnFall(rect,color,dirX,rot) {
  fallingPieces.push(new FallingPiece(rect.left,rect.top,rect.width,rect.height,color,rot||0,dirX));
}

// ═══════════════════════════════════════
// LAYERS
// ═══════════════════════════════════════
const activeTearProfile = (window.TearProfiles && window.TearProfiles.getDefaultProfile)
  ? window.TearProfiles.getDefaultProfile()
  : { stripThreshold: 60, topThreshold: 80, stripCount: 7 };
const TOTAL=10, STRIPS=activeTearProfile.stripCount, THRESHOLD=activeTearProfile.stripThreshold, TOP_THRESHOLD=activeTearProfile.topThreshold;
const STACK_FULL = { x: 1.2, y: 1.8, size: 0.5 };
const STACK_THIN = { x: 0.12, y: 0.18, size: 0.04 };
let tornCount=0;
const COLORS=[
  '#E2D6C8', // blanket
  '#D9CCBC',
  '#CFC4B4', // mushroom
  '#C3B49C',
  '#B48D54', // oak
  '#A77C4D',
  '#987050',
  '#945534', // autumn fern variant (avoids cardboard brown match)
  '#7C7A58', // khaki moss
  '#2D2D25'  // cinder
];
const layerState=[];
const HAPPY_MESSAGES = [
  'Great job!',
  'Nicely done!',
  'Awesome work!',
  'Perfect peel!',
  'You tore through it!',
  'Beautifully done!'
];
const archiveWall = document.getElementById('archiveWall');
let archiveCount = 0;
let isArchiving = false;
let completionShown = false;
let completionTimer = null;

function updateCount() { document.getElementById('cNum').textContent=tornCount; }
function isNotebookComplete() { return layerState.every(s => s.topTorn); }

function getLayerGeometry(li, stackMode = STACK_FULL) {
  return {
    left: li * stackMode.x,
    top: li * stackMode.y,
    width: 460 - li * stackMode.size,
    height: 580 - li * stackMode.size
  };
}

function applyNotebookThickness(mode = 'full') {
  const frame = document.getElementById('frame');
  if (!frame) return;
  const stackMode = mode === 'thin' ? STACK_THIN : STACK_FULL;
  frame.querySelectorAll('.paper-layer').forEach(layer => {
    const li = +layer.dataset.layer;
    const g = getLayerGeometry(li, stackMode);
    layer.style.left = `${g.left}px`;
    layer.style.top = `${g.top}px`;
    layer.style.width = `${g.width}px`;
    layer.style.height = `${g.height}px`;
    if (mode === 'thin') {
      // Make end-state clearly thinner: collapse visual depth of old sheets.
      if (li > 1) {
        layer.style.opacity = '0.14';
      } else if (li === 1) {
        layer.style.opacity = '0.38';
      } else {
        layer.style.opacity = '1';
      }
      const inner = layer.querySelector('.paper-inner');
      if (inner) {
        inner.style.borderWidth = li === 0 ? '2px' : '1px';
        inner.style.boxShadow = 'none';
      }
    }
  });
}

function hexToRgb(hex) {
  const h = hex.replace('#', '');
  const v = h.length === 3
    ? h.split('').map(c => c + c).join('')
    : h;
  const n = parseInt(v, 16);
  return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
}

function getSheetInk(hex) {
  const { r, g, b } = hexToRgb(hex);
  // Relative luminance (sRGB, simple approximation)
  const lum = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
  if (lum < 0.45) {
    return {
      title: 'rgba(247,241,230,0.5)',
      num: 'rgba(247,241,230,0.88)',
      line: 'rgba(247,241,230,0.42)'
    };
  }
  return {
    title: 'rgba(45,45,37,0.36)',
    num: 'rgba(45,45,37,0.72)',
    line: 'rgba(45,45,37,0.28)'
  };
}

function randomHappyMessage() {
  return HAPPY_MESSAGES[Math.floor(Math.random() * HAPPY_MESSAGES.length)];
}

function showCompletionBoard() {
  const frame = document.getElementById('frame');
  if (!frame || frame.querySelector('.completion-board')) return;
  const board = document.createElement('div');
  board.className = 'completion-board';
  const msg = document.createElement('div');
  msg.className = 'msg';
  msg.textContent = randomHappyMessage();
  board.appendChild(msg);
  frame.appendChild(board);
  completionShown = true;
}

function sanitizeArchiveClone(root) {
  if (root.id) root.removeAttribute('id');
  root.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));
  root.querySelectorAll('.held,.dragging,.tearing').forEach(n => {
    n.classList.remove('held', 'dragging', 'tearing');
  });
}

function spawnFreshNotebook({ animateIn = false } = {}) {
  const wrapper = document.getElementById('frameWrapper');
  const frame = document.getElementById('frame');
  const spiral = document.getElementById('spiralBinding');
  if (!wrapper || !frame || !spiral) return;
  frame.className = 'frame';
  frame.innerHTML = '';
  spiral.className = 'spiral-binding';
  buildSpiral();
  buildNotebook(frame);
  completionShown = false;
  if (animateIn) {
    wrapper.classList.add('spawn-enter');
    requestAnimationFrame(() => {
      wrapper.classList.add('spawn-enter-active');
      setTimeout(() => {
        wrapper.classList.remove('spawn-enter', 'spawn-enter-active');
      }, 560);
    });
  }
}

function animateArchiveFly(snapshotClone) {
  const wrapper = document.getElementById('frameWrapper');
  if (!wrapper) return Promise.resolve();
  const startRect = wrapper.getBoundingClientRect();

  const placeholder = document.createElement('div');
  placeholder.className = 'archive-item';
  placeholder.style.opacity = '0';
  archiveWall.appendChild(placeholder);
  const targetRect = placeholder.getBoundingClientRect();
  placeholder.remove();

  const flyer = document.createElement('div');
  flyer.className = 'archive-flyer';
  flyer.style.left = `${startRect.left}px`;
  flyer.style.top = `${startRect.top}px`;
  flyer.style.width = `${startRect.width}px`;
  flyer.style.height = `${startRect.height}px`;
  flyer.style.opacity = '1';

  const movingClone = snapshotClone.cloneNode(true);
  movingClone.style.marginTop = '0';
  flyer.appendChild(movingClone);
  document.body.appendChild(flyer);

  const dx = targetRect.left - startRect.left;
  const dy = targetRect.top - startRect.top;
  const sx = targetRect.width / startRect.width;
  const sy = targetRect.height / startRect.height;

  requestAnimationFrame(() => {
    flyer.style.transform = `translate(${dx}px, ${dy}px) scale(${sx}, ${sy})`;
    flyer.style.opacity = '0.78';
  });

  return new Promise(resolve => {
    setTimeout(() => {
      flyer.remove();
      resolve();
    }, 540);
  });
}

async function archiveCurrentNotebook({ completed = false, animateFly = true } = {}) {
  if (isArchiving) return;
  isArchiving = true;
  stopCrinkle();
  if (completionTimer) {
    clearTimeout(completionTimer);
    completionTimer = null;
  }

  if (completed) showCompletionBoard();

  const wrapper = document.getElementById('frameWrapper');
  if (!wrapper) {
    isArchiving = false;
    return;
  }
  const clone = wrapper.cloneNode(true);
  sanitizeArchiveClone(clone);

  const flyPromise = animateFly ? animateArchiveFly(clone) : Promise.resolve();
  // Start incoming notebook animation immediately for seamless crossover.
  spawnFreshNotebook({ animateIn: true });
  await flyPromise;

  const card = document.createElement('div');
  card.className = 'archive-item';
  card.style.zIndex = String(archiveCount + 1);
  card.appendChild(clone);
  archiveWall.appendChild(card);
  archiveCount++;
  isArchiving = false;
}

function tearAllForTesting() {
  if (isArchiving || activeDrag) return;
  const frame = document.getElementById('frame');
  if (!frame) return;
  stopCrinkle();
  if (completionTimer) {
    clearTimeout(completionTimer);
    completionTimer = null;
  }

  frame.querySelectorAll('.strip').forEach(el => {
    el.classList.remove('dragging', 'tearing', 'held');
    el.classList.add('torn');
    el.style.cssText = '';
  });
  frame.querySelectorAll('.paper-top').forEach(el => {
    el.classList.remove('dragging');
    el.classList.add('torn');
    el.style.display = 'none';
  });
  frame.querySelectorAll('.tear-line').forEach(el => {
    el.style.display = 'none';
  });

  for (let li = 0; li < TOTAL; li++) {
    layerState[li].stripsTorn.fill(true);
    layerState[li].allStripsTorn = true;
    layerState[li].topTorn = true;
  }
  tornCount = TOTAL * (STRIPS + 1);
  updateCount();

  showCompletionBoard();
  completionTimer = setTimeout(() => {
    archiveCurrentNotebook({ completed: true, animateFly: true });
  }, 2000);
}

function isStripExposed(li,si) {
  for (let a=0;a<li;a++) {
    const sameColumnTorn = layerState[a].stripsTorn[si];
    const sheetOpened = layerState[a].stripsTorn.some(Boolean);
    if (!sameColumnTorn && !sheetOpened) return false;
  }
  return true;
}
function isTopExposed(li) {
  for (let a=0;a<li;a++) { if (!layerState[a].topTorn) return false; }
  return true;
}

function buildSpiral() {
  const sb = document.getElementById('spiralBinding');
  sb.innerHTML = '';
  const count = 15;
  const totalW = 440;
  const spacing = totalW / count;
  const r = 10; // coil radius

  let svg = `<svg class="spiral-svg" viewBox="0 0 ${totalW} 36" xmlns="http://www.w3.org/2000/svg">`;
  // Shadow layer
  svg += `<g opacity="0.12" transform="translate(1.5,1.5)">`;
  for (let i = 0; i < count; i++) {
    const cx = spacing * 0.5 + i * spacing;
    const cy = 18;
    // Back arc (behind paper)
    svg += `<path d="M${cx - r * 0.3},${cy + r + 2} A${r},${r} 0 1,1 ${cx + r * 0.3},${cy + r + 2}" fill="none" stroke="#000" stroke-width="2.5" stroke-linecap="round"/>`;
  }
  svg += `</g>`;

  // Back wires (behind paper — bottom half of coil)
  for (let i = 0; i < count; i++) {
    const cx = spacing * 0.5 + i * spacing;
    const cy = 16;
    // Bottom arc — goes behind the paper
    svg += `<path d="M${cx - r * 0.7},${cy + 4} Q${cx - r * 0.9},${cy + r + 5} ${cx},${cy + r + 5} Q${cx + r * 0.9},${cy + r + 5} ${cx + r * 0.7},${cy + 4}" fill="none" stroke="#2C2420" stroke-width="2.2" stroke-linecap="round"/>`;
  }

  // Front wires (above paper — top half of coil)
  for (let i = 0; i < count; i++) {
    const cx = spacing * 0.5 + i * spacing;
    const cy = 16;
    // Top arc — loops over the top
    svg += `<path d="M${cx - r * 0.7},${cy + 4} Q${cx - r * 1.1},${cy - r * 0.8} ${cx},${cy - r} Q${cx + r * 1.1},${cy - r * 0.8} ${cx + r * 0.7},${cy + 4}" fill="none" stroke="#3D3530" stroke-width="2.5" stroke-linecap="round"/>`;
    // Highlight for 3D metallic look
    svg += `<path d="M${cx - r * 0.5},${cy - r * 0.3} Q${cx},${cy - r * 1.05} ${cx + r * 0.5},${cy - r * 0.3}" fill="none" stroke="#6B5F55" stroke-width="1" stroke-linecap="round" opacity="0.5"/>`;
  }

  svg += `</svg>`;
  sb.innerHTML = svg;
}

function buildNotebook(frame) {
  frame.innerHTML='';
  tornCount=0; updateCount();
  fallingPieces=[];
  layerState.length=0;

  // Single source of truth for cardboard reveal behind all sheets.
  const backboard = document.createElement('div');
  backboard.className = 'backboard';
  frame.appendChild(backboard);

  for (let li=0;li<TOTAL;li++) {
    layerState.push({ stripsTorn:new Array(STRIPS).fill(false), allStripsTorn:false, topTorn:false });
  }

  for (let li=TOTAL-1;li>=0;li--) {
    const layer=document.createElement('div');
    layer.className='paper-layer';
    layer.dataset.layer=li;
    const g = getLayerGeometry(li, STACK_FULL);
    layer.style.cssText=`left:${g.left}px;top:${g.top}px;width:${g.width}px;height:${g.height}px;z-index:${TOTAL-li};`;

    const inner=document.createElement('div');
    inner.className='paper-inner';
    if (li>0) inner.style.boxShadow=`${0.5+li*0.2}px ${0.5+li*0.3}px 0 rgba(92,64,51,${0.02+li*0.006})`;

    const top=document.createElement('div');
    top.className='paper-top'; top.dataset.layer=li;
    top.style.background=COLORS[li];
    const ink = getSheetInk(COLORS[li]);
    const h1=document.createElement('h1'); h1.textContent='tear me.'; top.appendChild(h1);
    h1.style.color = ink.title;
    const topNum=document.createElement('span');
    topNum.className='strip-num'; topNum.style.cssText='position:absolute;bottom:8px;left:8px;';
    topNum.textContent=`${STRIPS+1}/${STRIPS+1}`;
    topNum.style.color = ink.num;
    top.appendChild(topNum);

    const tearLine=document.createElement('div');
    tearLine.className='tear-line'; tearLine.dataset.layer=li;
    tearLine.style.borderTopColor = ink.line;

    const sz=document.createElement('div');
    sz.className='strips-zone';
    sz.style.setProperty('--strip-count', STRIPS);
    for (let si=0;si<STRIPS;si++) {
      const slot=document.createElement('div');
      slot.className='strip-slot';
      slot.dataset.layer=li;
      slot.dataset.strip=si;

      const strip=document.createElement('div');
      strip.className='strip'; strip.style.background=COLORS[li];
      strip.dataset.layer=li; strip.dataset.strip=si;
      // Generate jagged tear edge (10-14 random y-offsets across strip width, in %)
      const jaggedCount = 10 + Math.floor(Math.random() * 5);
      const jaggedPts = [];
      for (let ji = 0; ji <= jaggedCount; ji++) {
        jaggedPts.push((Math.random() - 0.5) * 24); // ±12% vertical jitter for visible paper-fiber tear
      }
      strip.dataset.jagged = JSON.stringify(jaggedPts);
      const num=document.createElement('span');
      num.className='strip-num'; num.textContent=`${si+1}/${STRIPS+1}`;
      num.style.color = ink.num;
      strip.appendChild(num);
      slot.appendChild(strip);
      sz.appendChild(slot);
    }

    inner.appendChild(top); inner.appendChild(tearLine); inner.appendChild(sz);
    layer.appendChild(inner); frame.appendChild(layer);
  }
  bindAll(frame);
}

// ═══════════════════════════════════════
// DRAG & TEAR
// ═══════════════════════════════════════
let activeDrag=null;
let moveHandler=null, endHandler=null;

function bindAll(frame) {
  // Clean old handlers
  if (moveHandler) { window.removeEventListener('mousemove',moveHandler); window.removeEventListener('touchmove',moveHandler); }
  if (endHandler) { window.removeEventListener('mouseup',endHandler); window.removeEventListener('touchend',endHandler); }

  const getPos=(e)=> e.touches ? {x:e.touches[0].clientX,y:e.touches[0].clientY} : {x:e.clientX,y:e.clientY};

  frame.querySelectorAll('.strip').forEach(strip=>{
    const h=(e)=>{
      const li=+strip.dataset.layer, si=+strip.dataset.strip;
      if (layerState[li].stripsTorn[si]) return;
      if (!isStripExposed(li,si)) return;
      e.preventDefault(); initAudio();
      const pos = getPos(e);
      const paperInner = strip.closest('.paper-inner');
      activeDrag={
        type:'strip',
        el:strip,
        layer:li,
        strip:si,
        startX:pos.x,
        startY:pos.y,
        lastX:pos.x,
        lastY:pos.y,
        lastTime:performance.now(),
        velocity:0,
        progress:0,
        paperInner: paperInner
      };
      paperInner.style.overflow = 'visible';
      strip.classList.add('dragging');
    };
    strip.addEventListener('mousedown',h);
    strip.addEventListener('touchstart',h,{passive:false});
  });

  frame.querySelectorAll('.paper-top').forEach(top=>{
    const h=(e)=>{
      const li=+top.dataset.layer;
      if (layerState[li].topTorn||!layerState[li].allStripsTorn||!isTopExposed(li)) return;
      e.preventDefault(); initAudio();
      top.classList.add('tearable','dragging');
      const pos = getPos(e);
      activeDrag={
        type:'top',
        el:top,
        layer:li,
        startX:pos.x,
        startY:pos.y,
        lastX:pos.x,
        lastY:pos.y,
        lastTime:performance.now(),
        velocity:0,
        progress:0
      };
      top.closest('.paper-layer').style.zIndex=200;
    };
    top.addEventListener('mousedown',h);
    top.addEventListener('touchstart',h,{passive:false});
  });

  moveHandler=(e)=>{
    if (!activeDrag) return;
    const pos=getPos(e), dx=pos.x-activeDrag.startX, dy=pos.y-activeDrag.startY, el=activeDrag.el;
    const now = performance.now();
    const dt = Math.max((now - activeDrag.lastTime) / 1000, 1 / 120);
    const stepDx = pos.x - activeDrag.lastX;
    const stepDy = pos.y - activeDrag.lastY;
    activeDrag.velocity = Math.hypot(stepDx, stepDy) / (dt * 1000);
    activeDrag.lastX = pos.x;
    activeDrag.lastY = pos.y;
    activeDrag.lastTime = now;

    if (activeDrag.type==='strip') {
      if (dy<=1){el.style.transform='';el.style.opacity='';el.style.boxShadow='';el.style.filter='';el.style.clipPath='';el.classList.remove('tearing');stopCrinkle();return;}
      const p=Math.min(dy/THRESHOLD,1);
      activeDrag.progress = p;
      const curlX=-28*p, curlZ=dx*0.03, ty=dy*0.5, tx=dx*0.13;
      const scY=1-p*0.1, sh=5+p*18;
      el.style.transform=`perspective(320px) rotateX(${curlX}deg) rotateZ(${curlZ}deg) translateY(${ty}px) translateX(${tx}px) scaleY(${scY})`;
      el.style.opacity=1-p*0.12;
      el.style.boxShadow=`0 ${sh}px ${sh*1.7}px rgba(92,64,51,${0.05+p*0.13})`;
      el.style.filter=`brightness(${1.02-p*0.08}) contrast(${1+p*0.08})`;
      // Progressive tear clip-path
      if (!el.classList.contains('tearing')) el.classList.add('tearing');
      const jagged = JSON.parse(el.dataset.jagged || '[]');
      const tearY = p * 100; // percentage from top
      if (jagged.length > 1) {
        // Build jagged top edge polygon; bottom is full strip rect
        let poly = '';
        for (let ji = 0; ji < jagged.length; ji++) {
          const xPct = (ji / (jagged.length - 1)) * 100;
          const yPct = Math.max(0, tearY + jagged[ji] * p);
          poly += `${xPct}% ${yPct}%` + (ji < jagged.length - 1 ? ', ' : '');
        }
        // Close polygon along bottom-right, bottom-left
        poly += ', 100% 100%, 0% 100%';
        el.style.clipPath = `polygon(${poly})`;
      }
      if (p>0.08) {
        startCrinkle();
        updateCrinkle(p, activeDrag.velocity);
      } else {
        stopCrinkle();
      }
      if (p>=1) detachStrip(dx,dy);
    } else if (activeDrag.type==='top') {
      const dist=Math.sqrt(dx*dx+dy*dy);
      if (dist<2) return;
      const p=Math.min(dist/TOP_THRESHOLD,1);
      activeDrag.progress = p;
      const curlX=-14*p*Math.sign(dy||1), curlZ=dx*0.015;
      el.style.transform=`perspective(500px) rotateX(${curlX}deg) rotateZ(${curlZ}deg) translate(${dx*0.35}px,${dy*0.35}px)`;
      el.style.opacity=1-p*0.1;
      if (p>0.12) {
        startCrinkle();
        updateCrinkle(p, activeDrag.velocity);
      } else {
        stopCrinkle();
      }
      if (p>=1) tearTop(dx,dy);
    } else if (activeDrag.type==='held') {
      // Lerp held strip toward cursor position with smooth lag
      const targetX = pos.x - activeDrag.heldW / 2;
      const targetY = pos.y - activeDrag.heldH / 2;
      activeDrag.heldX += (targetX - activeDrag.heldX) * 0.3;
      activeDrag.heldY += (targetY - activeDrag.heldY) * 0.3;
      // Rotation based on horizontal movement
      const rotZ = clamp(stepDx * 0.8, -15, 15);
      activeDrag.heldRot += (rotZ - activeDrag.heldRot) * 0.3;
      el.style.left = activeDrag.heldX + 'px';
      el.style.top = activeDrag.heldY + 'px';
      el.style.transform = `rotateZ(${activeDrag.heldRot}deg)`;
    }
  };

  endHandler=()=>{
    if (!activeDrag) return;
    stopCrinkle();
    const el=activeDrag.el;

    // Phase 3: Release held strip — spawn falling piece and remove from DOM
    if (activeDrag.type==='held') {
      const rect = { left: activeDrag.heldX, top: activeDrag.heldY, width: activeDrag.heldW, height: activeDrag.heldH };
      spawnFall(rect, activeDrag.heldColor, activeDrag.heldRot >= 0 ? 1 : -1, activeDrag.heldRot * 0.5);
      el.remove(); // strip was moved to body in detachStrip; remove it entirely
      activeDrag=null;
      return;
    }

    // Phase 1 snap-back: reset clip-path, tearing class, and overflow
    if (activeDrag.paperInner) activeDrag.paperInner.style.overflow = '';
    el.classList.remove('dragging','tearing');
    el.style.clipPath='';
    el.style.transition='transform 0.4s cubic-bezier(0.34,1.56,0.64,1),opacity 0.2s,box-shadow 0.3s,filter 0.2s';
    el.style.transform=''; el.style.opacity=''; el.style.boxShadow=''; el.style.filter='';
    setTimeout(()=>{el.style.transition='';},450);
    activeDrag=null;
  };

  function detachStrip(dx,dy) {
    const {el,layer:li,strip:si,paperInner}=activeDrag;
    const speed = clamp(activeDrag.velocity / 1.2, 0, 1);
    stopCrinkle();
    playTear({ intensity: Math.max(0.4, activeDrag.progress), speed, direction: Math.sign(dx || 1) });

    // Reset overflow on paper-inner (strip is now position:fixed, escapes overflow)
    if (paperInner) paperInner.style.overflow = '';

    // Same state bookkeeping as old tearStrip
    layerState[li].stripsTorn[si]=true; tornCount++; updateCount();
    // Important: disable the old slot hitbox so newly exposed strips below are clickable.
    const slot = el.closest('.strip-slot');
    if (slot) slot.style.pointerEvents = 'none';
    if (layerState[li].stripsTorn.every(Boolean)) {
      layerState[li].allStripsTorn=true;
      const topEl=frame.querySelector(`.paper-top[data-layer="${li}"]`);
      if (topEl) topEl.classList.add('tearable');
    }

    // Convert to fixed position at current bounding rect
    const rect=el.getBoundingClientRect();
    el.classList.remove('dragging','tearing');
    el.classList.add('held');
    el.style.clipPath='';
    el.style.transform='';
    el.style.opacity='';
    el.style.boxShadow='';
    el.style.filter='';
    el.style.left=rect.left+'px';
    el.style.top=rect.top+'px';
    el.style.width=rect.width+'px';
    el.style.height=rect.height+'px';
    el.style.transition='none';

    // Move strip to body so it's guaranteed visible (escapes any overflow:hidden)
    document.body.appendChild(el);

    // Switch drag type to 'held'
    activeDrag.type='held';
    activeDrag.heldX=rect.left;
    activeDrag.heldY=rect.top;
    activeDrag.heldW=rect.width;
    activeDrag.heldH=rect.height;
    activeDrag.heldColor=COLORS[li];
    activeDrag.heldRot=0;
  }

  function tearTop(dx,dy) {
    const {el,layer:li}=activeDrag;
    const speed = clamp(activeDrag.velocity / 1.2, 0, 1);
    stopCrinkle();
    playTear({ intensity: Math.max(0.45, activeDrag.progress), speed, direction: Math.sign(dx || 1) });
    const rect=el.getBoundingClientRect();
    spawnFall(rect,COLORS[li],dx>=0?1:-1,dx*0.01);
    el.classList.add('torn'); el.style.cssText='display:none'; el.classList.remove('dragging');
    const tl=frame.querySelector(`.tear-line[data-layer="${li}"]`);
    if (tl) tl.style.display='none';
    layerState[li].topTorn=true; tornCount++; updateCount();
    el.closest('.paper-layer').style.zIndex=0;
    activeDrag=null;

    if (isNotebookComplete() && !isArchiving) {
      applyNotebookThickness('thin');
      showCompletionBoard();
      if (completionTimer) clearTimeout(completionTimer);
      completionTimer = setTimeout(() => {
        archiveCurrentNotebook({ completed: true, animateFly: true });
      }, 2000);
    }
  }

  window.addEventListener('mousemove',moveHandler);
  window.addEventListener('touchmove',moveHandler,{passive:false});
  window.addEventListener('mouseup',endHandler);
  window.addEventListener('touchend',endHandler);
}

// ═══════════════════════════════════════
// RESET — archive current, spawn fresh
// ═══════════════════════════════════════
document.getElementById('resetBtn').addEventListener('click', () => {
  if (isArchiving || activeDrag) return;
  initAudio();
  playWhoosh();
  archiveCurrentNotebook({ completed: completionShown || isNotebookComplete(), animateFly: true });
  setTimeout(() => playLand(), 120);
});

document.getElementById('tearAllBtn').addEventListener('click', () => {
  tearAllForTesting();
});

// ═══════════════════════════════════════
// INIT
// ═══════════════════════════════════════
buildSpiral();
buildNotebook(document.getElementById('frame'));
</script>
</body>
</html>